{
  "address": "0xb50f75b543cd5A7cC5b6A58A4412532752fb5c19",
  "abi": [],
  "transactionHash": "0x475a1bdb97f6b2821d0da4de1f92cf92e100b42819a539b1287032d4dad8030d",
  "receipt": {
    "to": null,
    "from": "0x45947dfDE271FDbB7759a1F71007528437682Ec2",
    "contractAddress": "0xb50f75b543cd5A7cC5b6A58A4412532752fb5c19",
    "transactionIndex": 1,
    "gasUsed": "72281",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x413b9a6e1fa4d8548ae3063e9ab369c980c53802edb8e57f1554a6b61be48e31",
    "transactionHash": "0x475a1bdb97f6b2821d0da4de1f92cf92e100b42819a539b1287032d4dad8030d",
    "logs": [],
    "blockNumber": 9493844,
    "cumulativeGasUsed": "72281",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "3754ff12c22bbcd82280df154a5c110c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/library/Lib.sol\":\"Lib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IPits.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\ninterface IPits {\\n    function validation() external view returns (bool);\\n\\n    function getTimeOut() external view returns (uint256);\\n\\n    function getTimeBelowMinimum() external view returns (uint256);\\n\\n    function getDaysOff(uint256 _timestamp) external view returns (uint256);\\n\\n    function getTotalDaysOff() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x78f6bd4f83335ef0ba713cc1a9b42c6ed988422dd53468e72c0c86526acdedff\",\"license\":\"MIT\"},\"contracts/library/Error.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nerror CsToHigh();\\nerror NotAContract();\\nerror NotYourToken();\\nerror NotAuthorized();\\nerror WrongMultiple();\\nerror CannotClaimNow();\\nerror TransferFailed();\\nerror InvalidTokenId();\\nerror InvalidLockTime();\\nerror NoMoreAnimalsAllowed();\\nerror LengthsNotEqual();\\nerror ZeroBalanceError();\\nerror CsIsBellowHundred();\\nerror NeandersmolsIsLocked();\\nerror BalanceIsInsufficient();\\nerror InvalidTokenForThisJob();\\nerror DevelopmentGroundIsLocked();\\nerror NeandersmolIsNotInDevelopmentGround();\\n\",\"keccak256\":\"0x66167beeb11f3505adbc01b1b22ff53d2c67db8b258ffa18a3b284949f1f006b\",\"license\":\"MIT\"},\"contracts/library/Lib.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport { IPits } from \\\"../interfaces/IPits.sol\\\";\\nimport { DevelopmentGroundIsLocked } from \\\"./Error.sol\\\";\\n\\nlibrary Lib {\\n    function getDevelopmentGroundBonesReward(\\n        uint256 _currentLockPeriod,\\n        uint256 _lockPeriod,\\n        uint256 _lastRewardTime,\\n        IPits _pits\\n    ) internal view returns (uint256) {\\n        if (_lockPeriod == 0) return 0;\\n        uint256 rewardRate = getRewardRate(_lockPeriod);\\n\\n        uint256 time = (block.timestamp - _lastRewardTime) / 1 days;\\n\\n        return\\n            (rewardRate *\\n                time -\\n                calculateFinalReward(_currentLockPeriod, _pits)) * 10 ** 18;\\n    }\\n\\n    function calculatePrimarySkill(\\n        uint256 _bonesStaked,\\n        uint256 _amountPosition,\\n        uint256 _currentLockPeriod,\\n        uint256 _tokenId,\\n        IPits _pits,\\n        mapping(uint256 => mapping(uint256 => uint256)) storage trackTime,\\n        mapping(uint256 => mapping(uint256 => uint256)) storage trackToken\\n    ) internal view returns (uint256) {\\n        if (_bonesStaked == 0) return 0;\\n        uint256 amount;\\n        for (uint256 i = 1; i <= _amountPosition; ) {\\n            uint256 time = (block.timestamp - trackTime[_tokenId][i]) / 1 days;\\n            uint256 stakedAmount = trackToken[_tokenId][trackTime[_tokenId][i]];\\n            amount += (time * stakedAmount);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return\\n            (amount -\\n                calculateFinalReward(_currentLockPeriod, _pits) *\\n                10 ** 20) / 10 ** 4;\\n    }\\n\\n    function calculateFinalReward(\\n        uint256 _currentLockPeriod,\\n        IPits _pits\\n    ) internal view returns (uint256) {\\n        uint256 amount;\\n\\n        if (_currentLockPeriod != _pits.getTimeOut()) {\\n            uint256 howLong = (block.timestamp - _pits.getTimeOut()) / 1 days;\\n            amount = (_pits.getTotalDaysOff() -\\n                _pits.getDaysOff(_currentLockPeriod) +\\n                howLong);\\n        }\\n        if (_currentLockPeriod == 0) {\\n            uint256 off;\\n            _pits.getTimeOut() != 0\\n                ? off = (block.timestamp - _pits.getTimeOut()) / 1 days\\n                : 0;\\n            if (_pits.validation()) off = _pits.getTotalDaysOff();\\n            amount = off;\\n        }\\n        return amount * 10;\\n    }\\n\\n    function getRewardRate(\\n        uint _lockTime\\n    ) internal pure returns (uint256 rewardRate) {\\n        if (_lockTime == 50 days) rewardRate = 10;\\n        if (_lockTime == 100 days) rewardRate = 50;\\n        if (_lockTime == 150 days) rewardRate = 100;\\n    }\\n\\n    function pitsValidation(IPits _pits) internal view {\\n        if (!_pits.validation()) revert DevelopmentGroundIsLocked();\\n    }\\n\\n    function removeItem(\\n        uint256[] storage _element,\\n        uint256 _removeElement\\n    ) internal {\\n        uint256 i;\\n        for (; i < _element.length; ) {\\n            if (_element[i] == _removeElement) {\\n                _element[i] = _element[_element.length - 1];\\n                _element.pop();\\n                break;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x31e0b681e04a9c4f0298dfec0675601e7aca00a1a670d2db6343c10370917d89\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60566050600b82828239805160001a6073146043577f4e487b7100000000000000000000000000000000000000000000000000000000600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220433a82667c014865e7c275448726de50cf2008775f6cfbbfafbddcb3c413dec964736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220433a82667c014865e7c275448726de50cf2008775f6cfbbfafbddcb3c413dec964736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}